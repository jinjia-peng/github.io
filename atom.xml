<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vector123</title>
  
  <subtitle>Vector123 Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.vector123.com/"/>
  <updated>2018-05-09T14:20:19.908Z</updated>
  <id>http://www.vector123.com/</id>
  
  <author>
    <name>Jinjia.Peng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>生活与算法</title>
    <link href="http://www.vector123.com/2018/05/09/%E7%94%9F%E6%B4%BB%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>http://www.vector123.com/2018/05/09/生活与算法/</id>
    <published>2018-05-09T14:17:35.000Z</published>
    <updated>2018-05-09T14:20:19.908Z</updated>
    
    <content type="html"><![CDATA[<ol><li>煮饭做菜运用贪心算法，充分利用多进程并行的优势，用最少时间完成烹饪。</li><li>扫地使用分治算法，分而治之，逐块解决。</li><li>批量处理生产效率更高，设置一缓冲区，缓冲区满时，集中进行处理。</li><li>收纳物品与扔东西，可参考缓存淘汰算法——LRU，近期使用频率低的物品收起，扔东西也是同样如此。</li><li>哈夫曼编码给最常用的字符最短的编码，最常用的东西放在最显眼、最方便触及的地方。</li></ol><p>————————完————————</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;煮饭做菜运用贪心算法，充分利用多进程并行的优势，用最少时间完成烹饪。&lt;/li&gt;
&lt;li&gt;扫地使用分治算法，分而治之，逐块解决。&lt;/li&gt;
&lt;li&gt;批量处理生产效率更高，设置一缓冲区，缓冲区满时，集中进行处理。&lt;/li&gt;
&lt;li&gt;收纳物品与扔东西，可参考缓存淘汰算法——LRU，近期使用频率低的物品收起，扔东西也是同样如此。&lt;/li&gt;
&lt;li&gt;哈夫曼编码给最常用的字符最短的编码，最常用的东西放在最显眼、最方便触及的地方。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;————————完————————&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>macOS 优秀应用推荐</title>
    <link href="http://www.vector123.com/2018/03/25/macOS-%E4%BC%98%E7%A7%80%E5%BA%94%E7%94%A8%E6%8E%A8%E8%8D%90/"/>
    <id>http://www.vector123.com/2018/03/25/macOS-优秀应用推荐/</id>
    <published>2018-03-24T16:00:00.000Z</published>
    <updated>2018-04-10T15:50:16.232Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快速预览（Quick-Look）——一指禅"><a href="#快速预览（Quick-Look）——一指禅" class="headerlink" title="快速预览（Quick Look）——一指禅"></a>快速预览（Quick Look）——一指禅</h2><p>快速预览功能可以在不开启外部软件的情况下按下空格键，立即呈现文件内容或文件夹基本信息。系统本身已经支持常见文件预览功能，如各种图像、PDF、MP3、MP4、文本文件等。对于程序员而言，自然还需要更丰富的插件。Markdown、JSON、高亮显示各种语言代码、预览压缩文件中包含的内容、Android apk 安装包基本信息等。当只想查看而不修改文件时，按空格键是最佳操作，选中文件按下空格就立即弹出，相比使用程序打开要快速得多。适用于开发人员的有用的快速查看插件列表点击此<a href="https://github.com/sindresorhus/quick-look-plugins" target="_blank" rel="noopener">链接</a>获取。</p><p><img src="https://raw.githubusercontent.com/sindresorhus/quick-look-plugins/master/screenshots/QLColorCode.png" alt="QLColorCode"></p><a id="more"></a><h2 id="Alfred——效率神器"><a href="#Alfred——效率神器" class="headerlink" title="Alfred——效率神器"></a>Alfred——效率神器</h2><p><a href="https://www.alfredapp.com/" target="_blank" rel="noopener">Alfred</a> 小帽子，通过热键、关键词、文字扩展等功能来提高效率。Alfred 可以搜索 macOS 和网络，通过自定义操作更加有效地操作 macOS 。Alfred Workflow 插件，可以扩展任意功能，拥有无限自动化潜力的工具台软件，实现一切有关自动化的想法。Workflow 插件支持 PHP、Bash、Perl、Ruby、Python、JavaScript 和 AppleScript 等多种脚本语言编程。</p><p>先回想一下，你现在打开了多个应用程序，正在编程中遇到了 bug，想通过搜索引擎寻找答案，你接下来的操作会是怎样？一般的流程会是这样子，用鼠标或 <code>Command + Tab</code> 快捷键切换到浏览器，把焦点定位到输入框输入问题按回车，等待返回结果，最后切换 IDE。在这个操作流程中，程序间的窗口切换是最耗时的，不能以常量时间精准定位应用程序，以及快速进行搜索。借助 Alfred Workflow，操作可以是这样子的。按 <code>Command + 【空格】</code> 快捷键呼出输入框，输入问题按回车，按快捷键 <code>Alt + A</code> 切换回 IDE。这一过程手指不需要离开键盘，搜索引擎的指定也是可以快速选择，程序的切换时间跟你打开的应用窗口数量、顺序、位置没有关系。</p><p><img src="https://i.loli.net/2018/03/26/5ab9173fcfb46.png" alt="Alfred Search"></p><p>再来看一个应用场景，获取本机内网或公网 IP。按<code>Command + 【空格】</code>快捷键呼出输入框，输入 <code>ip</code> 关键词，激活 <a href="http://www.packal.org/workflow/whats-my-ip" target="_blank" rel="noopener">MyIP Workflow</a> 插件，内网和公网 IP 地址即刻在列表框中展示出来，选中按回车即可将 IP 保存到剪切板。</p><p><img src="https://i.loli.net/2018/03/26/5ab9173f90d55.png" alt="获取IP地址"></p><p>经常用网易云音乐的听歌的童鞋可能需要这样的一个功能，听到好的的歌曲要点击喜欢加入到歌单列表，普通的操作是打开网易云音乐，鼠标点击【喜欢】按钮，最后切换目标程序。而通过 <a href="https://github.com/ericwen229/AlfredWorkflows" target="_blank" rel="noopener">Netease Music Controls Workflow</a> 操作可以是这样子的，按 <code>Command + 【空格】</code>，输入 <code>nmlike</code> 关键词按回车，即可把当前播放的歌曲加入到我的歌单中。这一过程，当前程序没有失去焦点，没有程序切换，就能快速的把歌曲加入的歌单中，非常便捷的操作。</p><p><img src="https://i.loli.net/2018/03/26/5ab9173f5f2d0.png" alt="Netease Music Controls"></p><p>快速获取天气预报</p><p><img src="https://i.loli.net/2018/03/26/5ab9173fd8dc1.png" alt="天气预报"></p><h2 id="Vim——编辑器之神"><a href="#Vim——编辑器之神" class="headerlink" title="Vim——编辑器之神"></a>Vim——编辑器之神</h2><p><a href="https://zh.wikipedia.org/wiki/Vim" target="_blank" rel="noopener">Vim</a>是一款文本编辑器，和 Emacs 并列成为类 Unix 系统用户最喜欢的编辑器。具有代码补全、编译错误跳转以及方便编程的功能，在程序员中被广泛使用。Vim 的学习曲线非常陡峭，学习 Vim 在开始时是痛苦的，学习过程会很缓慢，需要几天的学习适应。开始在 Vim 模式下进行编码，模式的切换、指令的执行、代码间的跳转会很不适与纠结，需要舍弃之前的操作习惯。用 Vim 之后，多数情况下，都不需要键盘上的方向键，取而代之是使用 <code>H</code>、<code>J</code>、<code>K</code>、<code>L</code> 按键。</p><p>我是一个 Vim 党（伪）。我的编码环境不是在 Vim 编辑器中进行的，在 Vim 中搭建配置编译环境麻烦和折腾，整体体验与实用程度都比专业的 IDE 差好多。但在很多 IDE、编辑器，我都会安装 Vim 插件，从而使用常用的 Vim 键位。比如 IntelliJ IDEA 家的 IDE 我会安装 Vim Emulation，Sublime Text 开启 Vim 模式，Chrome 浏览器会装 <a href="https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb" target="_blank" rel="noopener">Vimium</a> 插件。通过各个 Vim 插件的配合，几乎所有的操作都可以键盘按键完成，不需要使用鼠标或触控板。Chrome 中的 Vimium 插件是值得推荐的，最多只需按三个键就可以打开任一链接。</p><p>Vimium 基本用法</p><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>j</td><td>向下滚动</td></tr><tr><td>k</td><td>向上滚动</td></tr><tr><td>d</td><td>向下翻半页</td></tr><tr><td>u</td><td>向上翻半页</td></tr><tr><td>G</td><td>滚动到页面最底部</td></tr><tr><td>gg</td><td>滚动到页面最</td></tr><tr><td>gi</td><td>前页面第一个输入框会获得焦点</td></tr></tbody></table><h2 id="更多应用"><a href="#更多应用" class="headerlink" title="更多应用"></a>更多应用</h2><ol><li><p><a href="https://github.com/fikovnik/ShiftIt" target="_blank" rel="noopener">ShiftIt</a>——窗口管理工具。开源免费应用，可以控制窗口最大化、全屏、以及把容器移动到指定的显示屏，很好的替代鼠标或触摸板点击操作，实现全键盘操作。 </p></li><li><p><a href="https://github.com/tekezo/Karabiner-Elements" target="_blank" rel="noopener">Karabiner-Elements</a>——自定义按键工具。好用，但配置稍麻烦。</p></li><li><p><a href="https://www.iterm2.com" target="_blank" rel="noopener">iTerm2</a>——好用的终端工具。</p></li><li><p><a href="https://itunes.apple.com/us/app/just-focus/id1142151959?mt=12" target="_blank" rel="noopener">JustFocus</a>——蕃茄钟应用。全屏提醒，壁纸使用 Unsplash 最新照片。更棒的一点是应用支持 Aflred Workflow。</p></li><li><p><a href="https://www.sublimetext.com" target="_blank" rel="noopener">Sublime Text</a>——代码编辑器软件。有丰富的插件扩展，速度快，自动保存文件。</p></li><li><p><a href="https://lhc70000.github.io/iina/zh-cn" target="_blank" rel="noopener">IINA</a>——现代的macOS视频播放器。友好的用户界面，基于开源播放器MPV，支持几乎所有常用媒体的格式。</p></li><li><p><a href="http://www.xmind.net" target="_blank" rel="noopener">XMind</a>——思维导图工具。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>苹果触控板 Magic Trackpad</strong> 非常好用，表面触感细腻，可以在任意方向滚动、在网页间轻扫、双指开合、旋转待手势操作，高效快速操作。如果不设计 UI 或打游戏，几乎不需要鼠标。</p><p><strong>不需要关机</strong>。 使用 MacBook 不需要关机，合上屏幕就可以拿走，打开唤醒几秒内即可使用。长时间不关机，系统也不会卡，如果不是系统更新或安装一些软件需要重启生效，我想可以像服务器一样不用关机。系统不需要重启带来的好算是省时间，每天早上不需要坐在电脑前等待系统启动。<br>macOS 是一个优秀的操作系统，细节体验做得很好，有众多外观功能强大的优秀软件。使用快捷键、Vim 插件、Aflred Workflow 等工具正确高效的完成操作，降低无效操作，把时间共存重要的事情上，久而久之但能做更多的事。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;快速预览（Quick-Look）——一指禅&quot;&gt;&lt;a href=&quot;#快速预览（Quick-Look）——一指禅&quot; class=&quot;headerlink&quot; title=&quot;快速预览（Quick Look）——一指禅&quot;&gt;&lt;/a&gt;快速预览（Quick Look）——一指禅&lt;/h2&gt;&lt;p&gt;快速预览功能可以在不开启外部软件的情况下按下空格键，立即呈现文件内容或文件夹基本信息。系统本身已经支持常见文件预览功能，如各种图像、PDF、MP3、MP4、文本文件等。对于程序员而言，自然还需要更丰富的插件。Markdown、JSON、高亮显示各种语言代码、预览压缩文件中包含的内容、Android apk 安装包基本信息等。当只想查看而不修改文件时，按空格键是最佳操作，选中文件按下空格就立即弹出，相比使用程序打开要快速得多。适用于开发人员的有用的快速查看插件列表点击此&lt;a href=&quot;https://github.com/sindresorhus/quick-look-plugins&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;链接&lt;/a&gt;获取。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/sindresorhus/quick-look-plugins/master/screenshots/QLColorCode.png&quot; alt=&quot;QLColorCode&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>UI设计开发组件工程化</title>
    <link href="http://www.vector123.com/2017/09/21/UI%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E7%BB%84%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    <id>http://www.vector123.com/2017/09/21/UI设计开发组件工程化/</id>
    <published>2017-09-20T16:00:00.000Z</published>
    <updated>2018-04-10T15:48:42.139Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在移动应用开发中，业务的不断演化，交互界面也跟着变更、改版和换肤，为了面对这种变化而带来较大的开发成本，从可维护性、复用性的角度去思考 UI 设计和项目架构组件工程化。UI 设计组件工程化设计分为三层：<strong>最小元素层</strong>、<strong>样式层</strong>、<strong>布局层</strong>，通过分层隔离的方式达到解耦、复用、较小成本应对需求的升级变化。<strong>布局层依赖样式层，样式层依赖最小元素层，最小元素层是具体基础的视觉元素</strong>。下面介绍关于这三层的划分，以及在 Android 平台上的实现。</p><p><img src="https://i.loli.net/2018/04/10/5accd2d1e6150.png" alt="UI 实现抽象层次"></p><a id="more"></a><h2 id="最小元素层"><a href="#最小元素层" class="headerlink" title="最小元素层"></a>最小元素层</h2><p>最小元素是设计或编码上不可再细分的度量单位。最小元素有：主题色、背景色、高亮色、文字主颜色、文字次要颜色、分割线颜色、页面边距、可点击组件边距、不可点击组件边距……</p><p>明确了最小元素后，将这些最小元素抽离出来，赋予有意义的名称，放置在资源文件中。一般性，好的设计，最小元素的数量不会有太多。因此不用担心定义过多的最小元素。在编码过程中，使用这些最小元素通过引用资源文件预定义好的常量值，不要硬编码写死。使用与定义分开，不关心最小元素具体值，只管引用元素值的资源 ID。依赖资源 ID 的好算是，一处改动全局生效，换肤无痛。</p><h4 id="最小元素创建"><a href="#最小元素创建" class="headerlink" title="最小元素创建"></a>最小元素创建</h4><ol><li><p>colors.xml：定义最小元素的主题色、背景色、主文本颜色、次文本颜色……</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">"colorPrimary"</span>&gt;</span>#393A3F<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">"colorPrimaryDark"</span>&gt;</span>#393A3F<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">"colorAccent"</span>&gt;</span>#31C131<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>dimens.xml：定义最小元素的页面边距、标题与内容的文本大小、圆角矩形半径……</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">"activity_horizontal_margin"</span>&gt;</span>16dp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">"activity_vertical_margin"</span>&gt;</span>16dp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">"round_rect_radius"</span>&gt;</span>3dp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>ids.xml：定义组件 id。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"recycler_view"</span> <span class="attr">type</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"swipe_refresh_layout"</span> <span class="attr">type</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"msg_tv"</span> <span class="attr">type</span>=<span class="string">"id"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>strings.xml：定义字符串文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"app_name"</span>&gt;</span>UI 组件工程化的实现<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="样式层"><a href="#样式层" class="headerlink" title="样式层"></a>样式层</h2><p>样式的创建是把最小元素组合起来，创建好的样式供布局文件使用。使用样式的好处是，复用与统一集中管理。对于有差异的组件样式，利用重载机制进行重写或扩展。</p><h4 id="样式实现"><a href="#样式实现" class="headerlink" title="样式实现"></a>样式实现</h4><p>以实现消息中心组件为例子，讲讲在 Android 平台上的实现，消息中心组件中包含了四个组件，分别是最外层的容器（<code>Layout</code>）、左侧的小图标和标题（<code>TextView</code> 组件可同时设置 icon 和 title）、右侧的箭头（<code>ImageView</code>），分割线（<code>View</code>）。把创建的样式存放在 <code>style.xml</code> 文件中，每一个样式可以包含组件的宽高、字体大小颜色、边距、相对位置等。</p><p><img src="https://i.loli.net/2018/04/10/5acccf0e7e941.png" alt="消息中心项"></p><p>外层容器样式<br>    <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"ItemLayoutStyle"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:layout_width"</span>&gt;</span>match_parent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:layout_height"</span>&gt;</span>wrap_content<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>标题样式<br>    <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"ItemTitleStyle"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:id"</span>&gt;</span>@id/title_tv<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:layout_width"</span>&gt;</span>wrap_content<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:layout_height"</span>&gt;</span>wrap_content<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:textSize"</span>&gt;</span>@dimen/item_text_size<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:textColor"</span>&gt;</span>@android:color/black<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:layout_margin"</span>&gt;</span>@dimen/activity_horizontal_margin<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:drawablePadding"</span>&gt;</span>@dimen/item_drawable_padding<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>箭头样式<br>    <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"ItemArrowStyle"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:layout_width"</span>&gt;</span>wrap_content<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:layout_height"</span>&gt;</span>wrap_content<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:src"</span>&gt;</span>@drawable/ic_right_arrow<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:layout_alignParentEnd"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:layout_centerVertical"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:layout_marginStart"</span>&gt;</span>@dimen/activity_horizontal_margin<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:layout_marginEnd"</span>&gt;</span>@dimen/activity_horizontal_margin<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>分割线样式<br>    <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"ItemDividerStyle"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:layout_width"</span>&gt;</span>match_parent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:layout_height"</span>&gt;</span>@dimen/divider_height<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:layout_marginStart"</span>&gt;</span>@dimen/activity_horizontal_margin<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:background"</span>&gt;</span>@android:color/darker_gray<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:layout_below"</span>&gt;</span>@id/title_tv<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>可以看到这几个样式定义，没有硬编码使用具体的属性值，都是通过引用创建好的样式资源。</p><h2 id="布局层"><a href="#布局层" class="headerlink" title="布局层"></a>布局层</h2><p>布局层的专注点是创建组件，定位组件。通用的外观直接引用样式，特殊差异的属性值可以选择性的在样式文件继承重写或在布局文件中设置。</p><h4 id="布局实现"><a href="#布局实现" class="headerlink" title="布局实现"></a>布局实现</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--相对布局--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">style</span>=<span class="string">"@style/ItemLayoutStyle"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--文本视图：消息中心图标和标题--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">style</span>=<span class="string">"@style/ItemTitleStyle"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:drawableStart</span>=<span class="string">"@drawable/ic_message_center"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"@string/message_center"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--图片视图：箭头--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span> <span class="attr">style</span>=<span class="string">"@style/ItemArrowStyle"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--普通视图：分割线--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">"@style/ItemDividerStyle"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2018/04/10/5acccf0ea71f4.png" alt="布局文件"></p><p>可以看到布局层的代码量已经大大减少了，布局层的编码只有少量或没有元素具体值的存在。在这个布局文件中，组件相同的属性都是从样式文件中引用来的。目前为止，布局文件把每一项使用到组件都暴露出来，很分散，如果想在每个向右箭头增加状态描述，那样修改起来会很麻烦。把 icon、标题、向右箭头看成一个不可分的整体，封装在一个组件中，布局文件引用自定义组件，使代码更加内聚，修改扩展成本更小。每一项视图有差异的是 icon、标题、是否显示分割线，把三个属性是变量，提取出来后，把样式变量放到 <code>attrs.xml</code> 中。接着，实现解析自定义属性，赋予组件使其生效。最后，在布局文件中使用自定义组件。</p><ol><li><p>创建自定义属性</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">"ItemLayout"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"icon"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"title"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"showDivider"</span> <span class="attr">format</span>=<span class="string">"boolean"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>解析与使用自定义属性</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemLayout</span> <span class="keyword">extends</span> <span class="title">RelativeLayout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ItemLayout</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        init(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> Drawable iconDrawable;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> showDivider;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        inflate(context, R.layout.item, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ItemLayout);</span><br><span class="line">        <span class="comment">//获取标题</span></span><br><span class="line">        title = a.getString(R.styleable.ItemLayout_title);</span><br><span class="line">        <span class="comment">//获取 icon</span></span><br><span class="line">        iconDrawable = a.getDrawable(R.styleable.ItemLayout_icon);</span><br><span class="line">        <span class="comment">//是否显示分割线</span></span><br><span class="line">        showDivider = a.getBoolean(R.styleable.ItemLayout_showDivider, <span class="keyword">true</span>);</span><br><span class="line">        a.recycle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onFinishInflate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onFinishInflate();</span><br><span class="line"></span><br><span class="line">        TextView titleTv = (TextView) findViewById(R.id.title_tv);</span><br><span class="line">        View dividerView = findViewById(R.id.divider);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置标题</span></span><br><span class="line">        titleTv.setText(title);</span><br><span class="line">        <span class="comment">//设置 icon</span></span><br><span class="line">        titleTv.setCompoundDrawablesWithIntrinsicBounds(iconDrawable, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//显示或隐藏分割线</span></span><br><span class="line">        dividerView.setVisibility(showDivider ? View.VISIBLE : View.GONE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>布局文件中使用自定义组件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xyz.vector.ui.ItemLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:icon</span>=<span class="string">"@drawable/ic_message_center"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:title</span>=<span class="string">"@string/message_center"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">xyz.vector.ui.ItemLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:icon</span>=<span class="string">"@drawable/ic_conversion_amount"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:title</span>=<span class="string">"@string/my_wallet"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">xyz.vector.ui.ItemLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:icon</span>=<span class="string">"@drawable/ic_message_center"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:title</span>=<span class="string">"@string/message_center"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">xyz.vector.ui.ItemLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:icon</span>=<span class="string">"@drawable/ic_conversion_amount"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:title</span>=<span class="string">"@string/my_wallet"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>UI 组件工程化实现需要从设计者开始，对色彩，控件样式，布局排版字体等制定的一系列规范，用来指导之后的工作保持一致性和风格统一。借助 Sketch、Zeplin、蓝湖等工具，很方便的把设计师定义好的样式输出。输出的样式代码稍加修改就可使用，减少编码和沟通时间，更专注产品业务逻辑实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;在移动应用开发中，业务的不断演化，交互界面也跟着变更、改版和换肤，为了面对这种变化而带来较大的开发成本，从可维护性、复用性的角度去思考 UI 设计和项目架构组件工程化。UI 设计组件工程化设计分为三层：&lt;strong&gt;最小元素层&lt;/strong&gt;、&lt;strong&gt;样式层&lt;/strong&gt;、&lt;strong&gt;布局层&lt;/strong&gt;，通过分层隔离的方式达到解耦、复用、较小成本应对需求的升级变化。&lt;strong&gt;布局层依赖样式层，样式层依赖最小元素层，最小元素层是具体基础的视觉元素&lt;/strong&gt;。下面介绍关于这三层的划分，以及在 Android 平台上的实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/04/10/5accd2d1e6150.png&quot; alt=&quot;UI 实现抽象层次&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
